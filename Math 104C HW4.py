# -*- coding: utf-8 -*-
"""Math 104C HW4 - Yanwen Chen

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1xqmuObYtpSI_sLwySnG3umgVk-F_F-0h
"""

#Question 1
#(a)

import numpy as np
from scipy.linalg import solve_banded

N = 50  # number of grid points per dimension
D = 1.0  # diffusion coefficient
T = 0.1  # final time
dt = T / N  # time step

# Grid points
x = np.linspace(0, 1, N+1)
y = np.linspace(0, 1, N+1)

# Initial condition
u = np.outer(np.sin(np.pi * x), np.sin(np.pi * y))

# Coefficients for tridiagonal system
lower = -D * dt / (2 * (x[1] - x[0])**2) * np.ones(N-1)
diagonal = (1 + D * dt / (x[1] - x[0])**2) * np.ones(N-1)
upper = -D * dt / (2 * (x[1] - x[0])**2) * np.ones(N-1)
abcd = np.array([upper, diagonal, lower])

# Time stepping
# _ here means we dont use element here, just wanna make it goes that many times
for _ in range(int(T / dt)):
    # X-sweep: solve for each row
    for j in range(1, N):
        b = u[1:-1, j] + D * dt / (2 * (x[1] - x[0])**2) * (u[:-2, j] - 2 * u[1:-1, j] + u[2:, j])
        u[1:-1, j] = solve_banded((1, 1), abcd, b)

    # Y-sweep: solve for each col
    for i in range(1, N):
        b = u[i, 1:-1] + D * dt / (2 * (y[1] - y[0])**2) * (u[i, :-2] - 2 * u[i, 1:-1] + u[i, 2:])
        u[i, 1:-1] = solve_banded((1, 1), abcd, b)

# Print the solution at the final time
print(u)

#(b)
import numpy as np
from scipy.linalg import solve_banded

# Parameters
N = 500  # i make it bigger cuz when its 50 there is error
D = 1.0  
T = 0.1
dt = T / (4*N)  # time step

# Grid points
x = np.linspace(0, 1, N+1)
y = np.linspace(0, 1, N+1)

# Initial condition
u = np.outer(np.sin(np.pi * x), np.sin(np.pi * y))

# Coefficients for tridiagonal system
lower = -D * dt / (2 * (x[1] - x[0])**2) * np.ones(N-1)
diagonal = (1 + D * dt / (x[1] - x[0])**2) * np.ones(N-1)
upper = -D * dt / (2 * (x[1] - x[0])**2) * np.ones(N-1)
abcd = np.array([upper, diagonal, lower])

# Time stepping
for _ in range(int(T / dt)):
    # X-sweep: solve for each row
    for j in range(1, N):
        b = u[1:-1, j] + D * dt / (2 * (x[1] - x[0])**2) * (u[:-2, j] - 2 * u[1:-1, j] + u[2:, j])
        u[1:-1, j] = solve_banded((1, 1), abcd, b)

    # Y-sweep: solve for each column
    for i in range(1, N):
        b = u[i, 1:-1] + D * dt / (2 * (y[1] - y[0])**2) * (u[i, :-2] - 2 * u[i, 1:-1] + u[i, 2:])
        u[i, 1:-1] = solve_banded((1, 1), abcd, b)

# Print the solution at the final time
print(u)

# (c)
import numpy as np
from scipy.linalg import solve_banded
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

# Parameters
N = 50  # number of grid points per dimension
D = 1.0  # diffusion coefficient
T = 0.1  # final time
dt = T / (4*N)  # time step

# Grid points
x = np.linspace(0, 1, N+1)
y = np.linspace(0, 1, N+1)

# Initial condition
u = np.outer(np.sin(np.pi * x), np.sin(np.pi * y))

# Coefficients for tridiagonal system
lower = -D * dt / (2 * (x[1] - x[0])**2) * np.ones(N-1)
diagonal = (1 + D * dt / (x[1] - x[0])**2) * np.ones(N-1)
upper = -D * dt / (2 * (x[1] - x[0])**2) * np.ones(N-1)
abcd = np.array([upper, diagonal, lower])

# Function to plot the solution
def plot_solution(u, t):
    fig = plt.figure()
    ax = fig.add_subplot(111, projection='3d')
    X, Y = np.meshgrid(x, y)
    ax.plot_surface(X, Y, u, cmap='coolwarm')
    ax.set_title('t = ' + str(t))
    plt.show()

# Time stepping
for n in range(int(T / dt)):
    # X-sweep: solve for each row
    for j in range(1, N):
        b = u[1:-1, j] + D * dt / (2 * (x[1] - x[0])**2) * (u[:-2, j] - 2 * u[1:-1, j] + u[2:, j])
        u[1:-1, j] = solve_banded((1, 1), abcd, b)

    # Y-sweep: solve for each column
    for i in range(1, N):
        b = u[i, 1:-1] + D * dt / (2 * (y[1] - y[0])**2) * (u[i, :-2] - 2 * u[i, 1:-1] + u[i, 2:])
        u[i, 1:-1] = solve_banded((1, 1), abcd, b)

    # Plot the solution at three different times
    if n == int(N/4) or n == int(N/2) or n == int(3*N/4):
        plot_solution(u, n*dt)

# Problem 2 
# (a)

import numpy as np
import matplotlib.pyplot as plt

# Parameters
h = 0.02  # spatial grid size
lambda_ = 0.8  # Courant number
k = lambda_ * h  # time step
M = round(3/h)  # number of grid points

# Spatial grid
x = np.linspace(-1, 3, M+1)

# Initial conditions
u1 = np.where(np.abs(x) <= 1, 1 - np.abs(x), 0)
u2 = np.exp(-5*x**2)

# Forward-time forward-space scheme
def forward_time_forward_space(u):
    u_next = np.copy(u)
    u_next[:-1] -= lambda_ * (u[1:] - u[:-1])
    u_next[-1] = u_next[-2]
    return u_next

# Time stepping
u1_list = [u1]
u2_list = [u2]
for _ in range(40):
    u1 = forward_time_forward_space(u1)
    u2 = forward_time_forward_space(u2)
    u1_list.append(u1)
    u2_list.append(u2)

# Plot the solutions at each time step
for i, u in enumerate(u1_list):
    plt.plot(x, u, label=f't = {i*k}')
plt.title('Solution for initial condition 1')
plt.legend()
plt.show()

for i, u in enumerate(u2_list):
    plt.plot(x, u, label=f't = {i*k}')
plt.title('Solution for initial condition 2')
plt.legend()
plt.show()

#(b)

import numpy as np
import matplotlib.pyplot as plt

# Parameters
h = 0.02  # spatial grid size
lambda_ = 0.8  # Courant number
k = lambda_ * h  # time step
M = round(3/h)  # number of grid points

# Spatial grid
x = np.linspace(-1, 3, M+1)

# Initial conditions
u1 = np.where(np.abs(x) <= 1, 1 - np.abs(x), 0)
u2 = np.exp(-5*x**2)

# Forward-time forward-space scheme
def forward_time_forward_space(u):
    u_next = np.copy(u)
    u_next[:-1] -= lambda_ * (u[1:] - u[:-1])
    u_next[-1] = u_next[-2]
    return u_next

# Time stepping and calculation of growth rates
u1_list = [u1]
u2_list = [u2]
growth_rates_u1 = []
growth_rates_u2 = []
for _ in range(40):
    u1_old, u2_old = u1, u2
    u1 = forward_time_forward_space(u1)
    u2 = forward_time_forward_space(u2)
    u1_list.append(u1)
    u2_list.append(u2)
    growth_rates_u1.append(np.max(u1) / np.max(u1_old) - 1)
    growth_rates_u2.append(np.max(u2) / np.max(u2_old) - 1)

# Plot the growth rates
plt.plot(growth_rates_u1, label='Initial condition 1')
plt.plot(growth_rates_u2, label='Initial condition 2')
plt.title('Growth rate per time step')
plt.legend()
plt.show()

# (c)

import numpy as np
import matplotlib.pyplot as plt

# Parameters
h = 0.02  # spatial grid size
lambda_ = 0.8  # Courant number
k = lambda_ * h  # time step
M = round(3/h)  # number of grid points

# Spatial grid
x = np.linspace(-1, 3, M+1)

# Initial conditions
u1 = np.where(np.abs(x) <= 1, 1 - np.abs(x), 0)
u2 = np.exp(-5*x**2)

# Forward-time backward-space scheme
def forward_time_backward_space(u):
    u_next = np.copy(u)
    u_next[1:] -= lambda_ * (u[1:] - u[:-1])
    u_next[0] = 0
    return u_next

# Time stepping
u1_list = [u1]
u2_list = [u2]
for _ in range(40):
    u1 = forward_time_backward_space(u1)
    u2 = forward_time_backward_space(u2)
    u1_list.append(u1)
    u2_list.append(u2)

# Plot the solutions at each time step
for i, u in enumerate(u1_list):
    plt.plot(x, u, label=f't = {i*k}')
plt.title('Solution for initial condition 1')
plt.legend()
plt.show()

for i, u in enumerate(u2_list):
    plt.plot(x, u, label=f't = {i*k}')
plt.title('Solution for initial condition 2')
plt.legend()
plt.show()

